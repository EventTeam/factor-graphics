;;;score-fg|program tests
(define error-tolerance .07)
(define samples 1)
(define check-test (make-check-test-with-runs 1))


;;exact match
;; (check-test (lambda () (repeat samples (lambda () (score-fg-program '(node '(a 20 4)) '((a 20 4)) 10))))
;;             (lambda (x) (exp x))
;;             (- 1 (label-noise noise-params));;calculated by hand
;;             error-tolerance
;;             "single factor-graph check; exact match")
;;program w/ multiple possible derivations for the fg
;; (check-test (lambda () (repeat samples (lambda () (score-fg-program '(if (flip) (node '(a 20 4)) (node '(b 20 4))) '((a 20 4)) 30))))
;;             (lambda (x) (exp x))
;;             (+ (* .5 (- 1 (label-noise noise-params))) (* .5 (label-noise noise-params)));;calculated by hand
;;             error-tolerance
;;             "single factor-graph check; multiple derivations")

;;only check relative scores until selective model averaging is figured out
;; (check-test (lambda () (repeat samples (lambda () (> (score-fg-program '(node '(a 20 4)) '((a 20 4)) 30) (score-fg-program '(if (flip) (node '(a 20 4)) (node '(b 20 4))) '((a 20 4)) 30)))))
;;             (lambda (x) (if x 1 0))
;;             1;;calculated by hand
;;             error-tolerance
;;             "single factor-graph check; one node fg, multiple derivations program vs the best program")

;; (check-test (lambda () (repeat samples (lambda () (> (score-fg-program '(node '(a 20 4)) '((a 20 4)) 30) (score-fg-program '(node '(b 20 4)) '((a 20 4)) 30)))))
;;             (lambda (x) (if x 1 0))
;;             1;;calculated by hand
;;             error-tolerance
;;             "single factor-graph check; one node fg, mislabeled node vs the best program")


;; (check-test (lambda () (repeat samples (lambda () (> (score-fg-program-test (lambda () (node '(a 20 4))) '((a 20 4)) 30) (score-fg-program-test (lambda () (if (flip) (node '(a 20 4)) (node '(b 20 4)))) '((a 20 4)) 30)))))
;;             (lambda (x) (if x 1 0))
;;             1;;calculated by hand
;;             error-tolerance
;;             "single factor-graph check; one node fg, multiple derivations program vs the best program")

;; (check-test (lambda () (repeat samples (lambda () (> (score-fg-program-test (lambda () (node '(a 20 4))) '((a 20 4)) 30) (score-fg-program-test (lambda () (node '(b 20 4))) '((a 20 4)) 30)))))
;;             (lambda (x) (if x 1 0))
;;             1;;calculated by hand
;;             error-tolerance
;;             "single factor-graph check; one node fg, mislabeled node vs the best program")

;; ;;geometry differs slightly
;; (set-policy! 'noisy-number)
;; (check-test (lambda () (repeat samples (lambda () (equal? (score-fg-program-test (lambda () (node '(a 19 4))) '((a 20 4)) 30) (score-fg-program-test (lambda () (node '(a 20 4))) '((a 20 4)) 30)))))
;;             (lambda (x) (if x 1 0))
;;             1;;calculated by hand
;;             error-tolerance
;;             "similar geometry test")

;; (check-test (lambda () (repeat samples (lambda () (equal? (score-fg-program-test (lambda () (node '(a 10 4))) '((a 20 4)) 30) (score-fg-program-test (lambda () (node '(a 20 4))) '((a 20 4)) 30)))))
;;             (lambda (x) (if x 1 0))
;;             1;;calculated by hand
;;             error-tolerance
;;             "non-similar geometry test")

;; ;;line test
;; (check-test (lambda () (repeat
;;                         samples
;;                         (lambda ()
;;                           (> (score-fg-program-test (lambda () (node '(a 20 4) (node '(b 20 6))))
;;                                                     '((a 20 4) ((b 20 6))) 30)
;;                              (score-fg-program-test (lambda () (node '(a 20 4))) '((a 20 4) ((b 20 6))) 30)))))
;;             (lambda (x) (if x 1 0))
;;             1;;calculated by hand
;;             error-tolerance
;;             "single factor-graph check; two node fg, two node program vs one node program")

;;line with branching
(set-growth-noise! 0)
(set-label-noise! 0)
(check-test (lambda () (repeat
                        samples
                        (lambda ()
                          (= (score-fg-program-test
                              (lambda () (if (flip)
                                             (node '(a 20 4) (node '(b 20 6) (node '(a 20 6)) (node '(a 20 6))))
                                             (node '(a 20 4) (node '(b 20 6) (node '(a 20 6)) (node '(a 20 6))))))
                                             '((a 20 4) ((b 20 6) ((a 20 6)) ((a 20 6)))) 100)
                             (score-fg-program-test
                              (lambda () (node '(a 20 4) (node '(b 20 6) (node '(a 20 6)) (node '(a 20 6)))))
                              '((a 20 4) ((b 20 6) ((a 20 6)) ((a 20 6)))) 100)))))
                    (lambda (x) (if x 1 0))
                    1;;calculated by hand
                    error-tolerance
                    "single factor-graph check; line with branching fg, two programs that perform the same different derviation")

;;;scoring tests
(pretty-print (equal? (lazy-list->all-list ((lambda () (if (flip)                                             (node '(a 20 4) (node '(b 20 6) (node '(a 20 6)) (node '(a 20 6)))) 
                                             (node '(a 20 4) (node '(b 20 6) (node '(a 20 6)) (node '(a 20 6)))))))) '((a 20 4) ((b 20 6) ((a 20 6)) ((a 20 6))))))


(pretty-print (lazy-equal? ((lambda () (node '(a 20 4) (node '(b 20 6) (node '(a 20 6)) (node '(a 20 6)))))) (list->lazy-list '((a 20 4) ((b 20 6) ((a 20 6)) ((a 20 6)))))))
;; (define simplest-data '(a))
;; (define possible-program-sexprs  (list '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'b))) '(uniform-draw (list (node 'a (node 'b))))))
;; (define possible-programs (map (lambda (prog) (make-program '() prog)) possible-program-sexprs))

;;;scoring tests just to see if it runs
;; (evaluates?-test "score a single node program" (scoring '(node 'a) simplest-data  10))
;; (evaluates?-test "score a list of programs" (map (lambda (prog) (scoring prog simplest-data 10)) possible-program-sexprs))

;;;list-sorting tests 
;; ;;partition test
;; (define test-list '(1 2 3 5 6 7))
;; (equal?-test "split with 4" (my-partition < 4 test-list) '((1 2 3) (5 6 7)))
;; ;;my-list-sort test
;; (equal?-test "sorting test" (my-list-sort > test-list) (reverse test-list))
;;;combine-size-score test
;; (define sizes '(1 2 3))
;; (define scores '(-10 -20 -30))

;; (equal?-test "combine-size-score test" (combine-size-score sizes scores 1 .1) '(2.0 4.0 6.0))
;;;sort-by-score-and-size tests
;;test where growth noise is higher than label noise
;; (set-growth-noise! .8)
;; (set-label-noise! .2)
;; (define timed-sort-by-score-and-size (time-it sort-by-score-and-size "sort-by-score-and-size"))

;; (equal?-test "high-growth/low-label noise sort-by-score-and-size simplest data, based on score only" (sort-by-score-and-size possible-programs simplest-data 0 1) (map (lambda (prog) (make-program '() prog)) (list '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'a (node 'b)))) '(uniform-draw (list (node 'b))))))

;;test where growth noise is lower than label noise
;; (set-growth-noise! .2)
;; (set-label-noise! .8)

;; (equal?-test "low-growth/high-label noise sort-by-score-and-size simplest data, based on score only" (sort-by-score-and-size possible-programs simplest-data 0 1) (map (lambda (prog) (make-program '() prog)) (list '(uniform-draw (list (node 'b))) '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'a (node 'b)))))))

;; (equal?-test "sort-by-score-and-size simplest data, based on weight only" (timed-sort-by-score-and-size possible-programs simplest-data 1 0) (map (lambda (prog) (make-program '() prog)) (list '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'b))) '(uniform-draw (list (node 'a (node 'b)))))))


;;;best-n tests
;; (define timed-best-n (time-it best-n "best-n"))
;; (equal?-test "best-n by score only" (timed-best-n 2 possible-programs simplest-data 0 1) (map (lambda (prog) (make-program '() prog)) (list '(uniform-draw (list (node 'a))) '(uniform-draw (list (node 'a (node 'b)))))))

;;;church-iterated-compressions test
;; (define timed-iterated-compressions (time-it my-iterated-compressions "my-iterated-compressions"))

;;(define compressible-program (make-program '() '(node 'a (node 'a (node 'a (node 'a))))))

;; (evaluates?-test "my-iterated-compressions test" (my-iterated-compressions (lambda (x) x) compressible-program))

;;;beam-learn-search-compressions test
;;(define timed-beam-learn-search-compressions (time-it beam-learn-search-compressions "beam-learn-search"))
;; (define simplest-program (make-program '() '(uniform-draw (list (node 'a)))))

;; (evaluates?-test "beam-learn-search-compressions simplest-data" (timed-beam-learn-search-compressions simplest-data 10 simplest-program 0 1))

;; (define aaaadata '(a (a (a (a)))))

;; (evaluates?-test "beam-learn-search-compressions 4a data" (timed-beam-learn-search-compressions aaaadata 5 compressible-program 0 1))

;;;beam-learn test
;; (define init-data '((a) (a (b))))
;; (define init-expr (make-initial-sexpr init-data))
;; (define timed-beam-learn (time-it beam-learn))
;; (evaluates?-test "beam-learn test" (timed-beam-learn init-data init-expr 10 0 1))



;;;learn-model tests
;; (member?-test "make-initial-sexpr evaluation" (lazy-list->all-list (eval (make-initial-sexpr (list '(a) '(a (b)))))) (list '(a) '(a (b)) '(b) '(b (b))))

;; (define timed-learn-model (time-it learn-model))

;; (member?-test "learned-model" (lazy-list->all-list ((timed-learn-model '((a) (a (b))) 0 1))) '((a) (b) (a (b)) (b (b))))


