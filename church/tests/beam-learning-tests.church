(load "../testing.church")
;;;test parameters
(define error-tolerance .07)
(define samples 1)
(define check-test (make-check-test-with-runs 1))
(define (almost= a b)
  (< (abs (- b a)) error-tolerance))
;;;score-fg-image test
(evaluates?-test "sore-fg-image" (scoring-fg-image '(lambda () (node '(a 20 4))) 20))

;;;score-fg|program tests
;;;exact match
(check-test (lambda () (repeat samples (lambda () (score-fg-program '(lambda () (node '(a 20 4))) '((a 20 4)) 10))))
            (lambda (x) (exp x))
            (- 1 (label-noise noise-params));;calculated by hand
            error-tolerance
            "p(fg|program), single node")
;;;program w/ multiple possible derivations for the fg
(check-test (lambda () (repeat samples (lambda () (score-fg-program '(lambda () (if (flip) (node '(a 20 4)) (node '(b 20 4)))) '((a 20 4)) 30))))
             (lambda (x) (exp x))
             (+ (* .5 (- 1 (label-noise noise-params))) (* .5 (label-noise noise-params)));;calculated by hand
             (+ error-tolerance .03) ;;since it's probable to only get the high probability path and thus .4 probability
             "p(fg|program), single node w/ multiple derivations")
;;;multiple node test
(check-test (lambda () (repeat
                        samples
                        (lambda ()
                          (score-fg-program '(lambda () (node '(a 20 4) (node '(b 20 6))))
                                                    '((a 20 4) ((a 20 6))) 100))))
            (lambda (x) (exp x))
            (* (- 1 (label-noise noise-params)) (label-noise noise-params) (- 1 (growth-noise noise-params))) ;;calculated by hand
            error-tolerance
            "p(fg|program); two node")


;; ;;;geometry differs slightly
(check-test (lambda () (repeat samples (lambda () (equal? (score-fg-program '(lambda () (node '(a 19 4))) '((a 20 4)) 30) (score-fg-program '(lambda () (node '(a 20 4))) '((a 20 4)) 30)))))
            (lambda (x) (if x 1 0))
            1;;calculated by hand
            error-tolerance
            "similar geometry test")

(check-test (lambda () (repeat samples (lambda () (not (equal? (score-fg-program '(lambda () (node '(a 10 4))) '((a 20 4)) 30) (score-fg-program '(lambda () (node '(a 20 4))) '((a 20 4)) 30))))))
            (lambda (x) (if x 1 0))
            1;;calculated by hand
            error-tolerance
            "non-similar geometry test")



;;;scoring test
(check-test (lambda () (repeat samples (lambda () (scoring '(lambda () (node '(a 20 4))) '(((a 20 4)) ((a 20 4)) ((a 20 4))) 30))))
            (lambda (x) (exp x))
            (expt (- 1 (label-noise noise-params)) 3)
            error-tolerance
            "scoring test")


;;;list-sorting tests 
;;partition test
(define test-list '(1 2 3 5 6 7))
(equal?-test "split with 4" (my-partition < 4 test-list) '((1 2 3) (5 6 7)))
;;my-list-sort test
(equal?-test "sorting test" (my-list-sort > test-list) (reverse test-list))
;;;combine-size-score test
(equal?-test "combine-size-score test" (map round (combine-size-score '(1 2 3) (list (log 10) (log 20) (log 30)) 1 1))  '(-9. -18. -27.))
;; ;;;sort-by-score-and-size

(define timed-sort-by-score-and-size (time-it sort-by-score-and-size "sort-by-score-and-size"))
(let* ([sexprs (list '(lambda () (uniform-draw (list (node '(a 1 2)) (node '(a 1 2))))) '(lambda () (node '(b 1 2))))]
       [possible-programs (map (lambda (p) (make-program '() p)) sexprs)]
       [simplest-data '(((a 1 2)) ((a 1 2)))])
  (equal?-test "sort-by-score-and-size size-only" (timed-sort-by-score-and-size possible-programs simplest-data 1 0) (reverse possible-programs)))

(let* ([sexprs (list '(lambda () (uniform-draw (list (node '(a 1 2)) (node '(a 1 2))))) '(lambda () (node '(b 1 2))))]
       [possible-programs (map (lambda (p) (make-program '() p)) sexprs)]
       [simplest-data '(((a 1 2)) ((a 1 2)))])
  (equal?-test "sort-by-score-and-size score-only" (timed-sort-by-score-and-size possible-programs simplest-data 0 1) possible-programs))



;;;best-n tests
(define timed-best-n (time-it best-n "best-n"))
(let* ([sexprs (list '(lambda () (uniform-draw (list (node '(a 1 2))))) '(lambda () (uniform-draw (list (node '(a 1 2)) (node '(b 1 2))))))]
       [possible-programs (map (lambda (p) (make-program '() p)) sexprs)]
       [simplest-data '(((a 1 2)) ((a 1 2)))])
  (equal?-test "best-n by score only" (timed-best-n 1 possible-programs simplest-data 0 1) (list (make-program '() '(lambda () (uniform-draw (list (node '(a 1 2)))))))))

;;;church-iterated-compressions test
(define timed-iterated-compressions (time-it my-iterated-compressions "my-iterated-compressions"))
(let ([compressible-program (make-program '() '(lambda () (uniform-draw (list (node '(a 1 2)) (node '(a 1 2))))))])
  (evaluates?-test "my-iterated-compressions test" (timed-iterated-compressions (lambda (x) x) compressible-program)))

;;;beam-learn-search-compressions test
(define timed-beam-learn-search-compressions (time-it beam-learn-search-compressions "beam-learn-search"))

(let ([simplest-program (make-program '() '(lambda () (uniform-draw (list (node '(a 1 2))))))]
      [simplest-data '(((a 1 2)) ((a 1 2)))])
  (equal?-test "beam-learn-search-compressions, simplest program no compression" (timed-beam-learn-search-compressions simplest-data 10 simplest-program 0 1) '()))

(let ([compressible-program (make-program '() '(lambda () (uniform-draw (list (node '(a 1 2)) (node '(a 1 2))))))]
      [simplest-data '((('a 1 2)) (('a 1 2)))])
  (evaluates?-test "beam-learn-search-compressions simple compressible program" (timed-beam-learn-search-compressions simplest-data 10 compressible-program 0 1)))


;;;make-initial-sexpr test, this is a program that returns lazy factor graphs
(equal?-test "initial-sexpr test sexpr" (make-initial-sexpr '(((a 1 2)) ((a 1 2)))) '(lambda () (uniform-draw (list (node '(a 1 2)) (node '(a 1 2))))))

(equal?-test "initial sexpr evalutes to lazy-pair" (lazy-pair? ((eval (make-initial-sexpr '(((a 1 2)) ((a 1 2))))))) #t)

(member?-test "initial sexpr evalutes correctly" (lazy-list->all-list ((eval (make-initial-sexpr '(((a 1 2)) ((a 1 2))))))) '(((a 1 2)) ((b 1 2))))


;;;beam-learn test
;;beam learn takes a list of factors graphs as data and an sexpr
(evaluates?-test "beam-learn runs" (beam-learn '(((a 1 2)) ((a 1 2))) (make-initial-sexpr '(((a 1 2)) ((a 1 2)))) 5  1 0))

(member?-test "result of beam-learn evalutes" (lazy-list->all-list ((eval (beam-learn '(((a 1 2)) ((a 1 2))) (make-initial-sexpr '(((a 1 2)) ((a 1 2)))) 5  0 1)))) '(((a 1 2)) ((b 1 2))))

;;;learn-model tests
;;type check, learn-model should process a list of factor-graphs and return a function that generates factor graphs
(define timed-learn-model (time-it learn-model))
(member?-test "learned-model" ((timed-learn-model '(((a 1 2)) ((a 1 2))) 0 1)) '(((a 1 2)) ((b 1 2))))








(exit)