(load "../testing.church")
;;;test parameters
(define error-tolerance .07)
(define samples 1)
(define check-test (make-check-test-with-runs 1))
(define (almost= a b)
  (< (abs (- b a)) error-tolerance))

;;;church-iterated-compressions test
;;recursion test

;;(equal?-test "init-images test" (init-images) )

(define (init-images) (list "test.fg"))
(define fg '(N (data (label 1) (radius 10) (blobbiness 3.5) (Distance 5 .5) (Straightness 0 0.1))
              (N (data (label 2) (radius 5) (blobbiness 3.5) (Distance 3 .5) (Straightness 0 0.1))
                 (N (data (label 3) (radius 2) (blobbiness 3.5) (Distance 2 .5) (Straightness 0 0.1))
                    (N (data (label 4) (radius 5) (blobbiness 10) (Distance 5 .5) (Straightness 0 0.1)))
                    (N (data (label 5) (radius 5) (blobbiness 10) (Distance 5 .5) (Straightness 0 0.1)))))))

(define fg2 '(N (data (label 1) (radius 5) (blobbiness 10) (Distance 5 .5) (Straightness 0 0.1))))
(define images (init-images))
;;;init-images tests
(equal?-test "image->factor-graph test"
             (image->factor-graph (first images))
             fg)

;;;global test data
(define worse-than-initial-sexpr (list 'lambda '() (list (list 'uniform-draw  (list 'list (list 'lambda '() fg) (list 'lambda '() fg2))))))

(define models-for-comparison (let* ([sexprs (list (make-initial-sexpr images) worse-than-initial-sexpr)]
                                     [possible-programs (map (lambda (p) (make-program '() p)) sexprs)])
                                possible-programs))

;;;make-initial-sexpr test, this is a program that returns lazy factor graphs
;; (equal?-test "initial-sexpr test sexpr" (make-initial-sexpr images) (list 'lambda '() (list (list 'uniform-draw  (list 'list (list 'lambda '() fg))))))

;; ;;(pretty-print ((eval (make-initial-sexpr images))))
;; (equal?-test "initial sexpr evaluates to lazy-pair" (lazy-pair? ((eval (make-initial-sexpr images)))) #t)

;; (equal?-test "initial sexpr evaluates correctly" (lazy-list->all-list ((eval (make-initial-sexpr images)))) '(((1) (10) (3.5) (5 .5) (0 0.1)) (((2) (5) (3.5) (3 .5) (0 0.1)) (((3) (2) (3.5) (2 .5) (0 0.1)) (((4) (5) (10) (5 .5) (0 0.1)) ) (((5) (5) (10) (5 .5) (0 0.1)))))))




;; ;;;depth-iterated-compressions
;; (define timed-iterated-transformations (time-it depth-iterated-transformations "depth-iterated-transformations"))
;; (let* ([abstraction1 (make-named-abstraction 'F1 '(node V1) '(V1))]
;;        [program1 (make-program (list abstraction1) '(F1 (F1 1)))]
;;        [abstraction21 (make-named-abstraction 'F2 '(V2 V3) '(V2 V3))]
;;        [abstraction22 (make-named-abstraction 'F1 '(F2 node V1) '(V1))]
;;        [program2 (make-program (list abstraction21 abstraction22) '(F2 F1 (F2 F1 1)))]
;;        [abstraction3 (make-named-abstraction 'F2 '(V2 (F1 V3)) '(V2 V3))]
;;        [program3 (make-program (list abstraction3 abstraction1) '(F2 F1 1))]
;;        [abstraction4 (make-named-abstraction 'F2 '(F1 V2) '(V2))]
;;        [program4 (make-program (list abstraction4 abstraction1) '(F2 (F2 1)))]
;;        [abstraction5 (make-named-abstraction 'F1 '(let ([V1 ((uniform-draw (list (lambda () (F1)) (lambda () 1))))]) (node V1)) '())]
;;        [program5 (make-program (list abstraction5) '(F1))])
;;   (equal?-test "depth-iterated-transformations internalize-argument test"
;;                (timed-iterated-transformations (lambda (x) x) (make-program '() '(node (node 1))) 2)
;;                (list program1 program2 program3 program4 program5)))

;; ;;;log-prior (how do you normalize these values?)
;; (equal?-test "log-prior test" (log-prior (make-program '() '(+ 2 3 4))) -5)


;;;score-fg-top_program scoring test
;; (equal?-test "score-fg-top_program w/ program that can produce different topologies"
;;              (exp (score-fg-top_program (second models-for-comparison) '((data)) 10))
;;              (/ 1.0 2))

;; (equal?-test "score-fg-top_program w/ program that cannot produce target topologies"
;;              (exp (score-fg-top_program (first models-for-comparison) '((data)) 10))
;;              0.0)

;; (equal?-test "score-fg-top_program w/ program that produces exactly target topology"
;;              (exp (score-fg-top_program (first models-for-comparison) (eval fg) 10))
;;              1.0)
;;;generate-factor-graphs_top
;; (let ([graph (lazy-list->all-list (eval fg))])
;;   (equal?-test "generate-factor-graphs_top" (map scheme-format->python-format (generate-factor-graphs_top (first models-for-comparison) graph 2)) (list fg fg)))

;; (let ([graph (lazy-list->all-list (eval fg2))])
;;   (equal?-test "generate-factor-graphs_top" (map scheme-format->python-format (generate-factor-graphs_top (second models-for-comparison) graph 2)) (list fg2 fg2)))
;;;single-log-likelihood
(equal?-test "single-log-likelihood" (single-log-likelihood (first models-for-comparison) 10 (first images)) (log 1))
;;;log-likelihood
;; (equal?-test (log-likelihood images (first models-for-comparison) 10) (log 1))
;; (equal?-test (log-likelihood images (second models-for-comparison) 10) (log .5))
;;;sort-by-posterior
;; (define timed-sort-by-posterior (time-it sort-by-posterior "sort-by-posterior"))
;; (equal?-test "sort-by-posterior" (timed-sort-by-posterior images models-for-comparison) possible-programs)


;;;best-n tests
;; (define timed-best-n (time-it best-n "best-n"))
;; (equal?-test "best-n by score only" (timed-best-n images models-for-comparison 1) (make-initial-sexpr images))


;;;beam-learn-search-compressions test
;; (define timed-beam-learn-search-transformations (time-it beam-learn-search-transformations "beam-learn-search"))


;; (evaluates?-test "beam-learn-search-compressions simple compressible program" (timed-beam-learn-search-transformations images (make-initial-sexpr images) 1 2))


;;;beam-learn test
;; ;;beam learn takes a list of factors graphs as data and an sexpr
;; (evaluates?-test "beam-learn runs" (beam-learn images (make-initial-sexpr images) 1 2))


;;;learn-model tests
;; ;;type check, learn-model should process a list of factor-graphs and return a function that generates factor graphs
;; (define timed-learn-model (time-it learn-model))
;; (evaluates?-test "learned-model" ((timed-learn-model images 1 2)))


(exit)